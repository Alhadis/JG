#!/usr/bin/env node
"use strict";

const fs = require("fs");
const {join} = require("path");
const which = require("./which");


(async () => {
	const files = await findFiles(process.argv[2] || process.cwd());
	
	// Stuff we can lint with different NPM linters
	const js = [];
	const ts = [];
	const coffee = [];
	
	for(const [path, stats] of files){
		if(!stats.isFile()) continue;
		if(/\.jsx?$/i.test(path))                 js.push(path);
		else if(/\.tsx?$/i.test(path))            ts.push(path);
		else if(/\.(?:cson|coffee)$/i.test(path)) coffee.push(path);
		
		// Identify executables without file extensions
		else if(0o111 & stats.mode){
			let data = Buffer.alloc(80);
			const fd = fs.openSync(path, "r");
			const bytesRead = fs.readSync(fd, data, 0, 80, 0);
			data = (bytesRead < data.length ? data.slice(0, bytesRead) : data).toString();
			fs.closeSync(fd);
			
			const regex = /^#!(?:(?:\s*\S*\/|\s*(?=perl6?))(\S+))(?:(?:\s+\S+=\S*)*\s+(\S+))?/;
			const match = data.match(regex);
			if(null !== match){
				const interpreter = "env" === match[1]
					? (match[2] || "").split("/").pop()
					:  match[1];
				switch(interpreter){
					case "node":   js.push(path);     break;
					case "tsc":    ts.push(path);     break;
					case "coffee": coffee.push(path); break;
				}
			}
		}
	}
	
	// Ensure all required dependencies are available
	const missing = [];
	if(js.length && !await which("eslint"))         missing.push("eslint");
	if(ts.length && !await which("tslint"))         missing.push("tslint");
	if(coffee.length && !await which("coffeelint")) missing.push("coffeelint");
	if(missing.length){
		const names = missing.join(", ");
		process.stderr.write([
			`lint: Required linters not found in $PATH: ${names}`,
			`Run \`npm install --global ${names}\`, then try again\n`
		].join("\n\n"));
		process.exit(1);
	}
	
	if(js.length){
		const configPath = join(__dirname, "..", "eslint", ".eslintrc.json");
		console.log(js, findBasePath(js));
		0 && await exec(linters.eslint, ["--config", configPath, "--ext", "mjs,js", "--"], {
		
		});
	}
})();



async function findFiles(path, ignorePattern = /(?:^|[\\/])(?:\.git|node_modules)$/i){
	path = path || process.cwd();
	const files = await ls(path);
	const searches = [];
	for(const [path, stats] of files)
		if(stats.isDirectory() && !ignorePattern.test(path))
			searches.push(findFiles(path));
	
	await Promise.all(searches).then(results => {
		for(const map of results)
			for(const [path, stats] of map)
				files.set(path, stats);
	});
	return files;
}

async function ls(path){
	const files = await new Promise((resolve, reject) => {
		fs.readdir(path, (error, list) => error
			? reject(error)
			: resolve(list));
	});
	return new Map([...await Promise.all(
		files.map(file => new Promise((resolve, reject) => {
			file = join(path, file);
			fs.lstat(file, (error, stats) => error
				? reject(error)
				: resolve([file, stats]));
		}))
	)]);
}


/**
 * Locate the root directory shared by multiple paths.
 *
 * @param {String[]} paths - A list of filesystem paths
 * @return {String} root
 */
function findBasePath(paths){
	const POSIX = -1 !== paths[0].indexOf("/");
	let matched = [];
	
	// Spare ourselves the trouble if there's only one path.
	if(1 === paths.length){
		matched = (paths[0].replace(/[\\/]+$/, "")).split(/[\\/]/g);
		matched.pop();
	}
	else{
		const rows   = paths.map(d => d.split(/[\\/]/g));
		const width  = Math.max(...rows.map(d => d.length));
		const height = rows.length;
		let x;
		X: for(x = 0; x < width; ++x){
			const str = rows[0][x];
			for(let y = 1; y < height; ++y)
				if(str !== rows[y][x]) break X;
			matched.push(str);
		}
	}
	
	return matched.join(POSIX ? "/" : "\\");
}
