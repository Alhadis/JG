#!/usr/bin/env node
"use strict";

const fs = require("fs");
const {join, resolve} = require("path");
const {spawn} = require("child_process");
const which = require("./which");


(async () => {
	const paths = process.argv.slice(2);
	if(!paths.length)
		paths.push(".");
	lint(...paths);
})();


async function lint(...paths){
	paths = paths.filter(Boolean);
	
	const files = new Map();
	const maps = await Promise.all(paths.map(path => findFiles(resolve(path))));
	for(const map of maps)
		for(const [key, value] of map)
			files.set(key, value);

	// Stuff we can lint with different NPM linters
	const js = [];
	const ts = [];
	const coffee = [];

	for(const [path, stats] of files){
		if(!stats.isFile()) continue;
		if(/\.(?:mjs|jsx?)$/i.test(path))         js.push(path);
		else if(/\.tsx?$/i.test(path))            ts.push(path);
		else if(/\.(?:cson|coffee)$/i.test(path)) coffee.push(path);
		
		// Identify executables without file extensions
		else if(0o111 & stats.mode){
			let data = Buffer.alloc(80);
			const fd = fs.openSync(path, "r");
			const bytesRead = fs.readSync(fd, data, 0, 80, 0);
			data = (bytesRead < data.length ? data.slice(0, bytesRead) : data).toString();
			fs.closeSync(fd);
			
			const regex = /^#!(?:(?:\s*\S*\/|\s*(?=perl6?))(\S+))(?:(?:\s+\S+=\S*)*\s+(\S+))?/;
			const match = data.match(regex);
			if(null !== match){
				const interpreter = "env" === match[1]
					? (match[2] || "").split("/").pop()
					:  match[1];
				switch(interpreter){
					case "node":   js.push(path);     break;
					case "tsc":    ts.push(path);     break;
					case "coffee": coffee.push(path); break;
				}
			}
		}
	}
	
	// Ensure all required dependencies are available
	const missing = [];
	if(js.length     && !await which("eslint"))     missing.push("eslint");
	if(ts.length     && !await which("tslint"))     missing.push("tslint");
	if(coffee.length && !await which("coffeelint")) missing.push("coffeelint");
	if(missing.length){
		const names = missing.join(", ");
		process.stderr.write([
			`lint: Required linters not found in $PATH: ${names}`,
			`Run \`npm install --global ${names}\`, then try again\n`
		].join("\n\n"));
		process.exit(1);
	}
	
	let code = 0;
	if(js.length)     (code = await lintJavaScript(...js))       && process.exit(code);
	if(ts.length)     (code = await lintTypeScript(...ts))       && process.exit(code);
	if(coffee.length) (code = await lintCoffeeScript(...coffee)) && process.exit(code);
}


async function run(cmd, args, verbose = false){
	verbose && process.stderr.write(`${cmd} ${args.join(" ")}\n`);
	const proc = spawn(cmd, args, {windowsHide: true, stdio: "inherit"});
	const code = await new Promise((resolve, reject) => {
		proc.on("close", code => resolve(code));
		proc.on("error", error => reject(error));
	});
	return code;
}

async function lintJavaScript(...files){
	return run("eslint", [
		"--ext", "mjs,js",
		"--", ...resolveFileList(files, /\.(?:mjs|jsx?)$/i),
	]);
}

async function lintTypeScript(...files){
	return run("tslint", [
		"--config", join(__dirname, "..", "tslint", "tslint.json"),
		"--", ...resolveFileList(files, /\.tsx?$/i),
	]);
}

async function lintCoffeeScript(...files){
	return run("coffeelint", [
		"-f", join(__dirname, "..", "coffeelint", "coffeelint.json"),
		...resolveFileList(files, /\.(?:cson|coffee)?$/i),
	]);
}


function resolveFileList(paths, extMatch){
	const noExt = [];
	const hasExt = [];
	for(const path of paths)
		extMatch.test(path) ? hasExt.push(path) : noExt.push(path)
	const list = [];
	if(hasExt.length) list.push(findBasePath(hasExt));
	if(noExt.length)  list.push(...noExt);
	return Array.from(new Set(list));
}


async function findFiles(path, ignorePattern = /(?:^|[\\/])(?:\.git|node_modules)$/i){
	path = path || process.cwd();
	const files = await ls(path);
	const searches = [];
	for(const [path, stats] of files)
		if(stats.isDirectory() && !ignorePattern.test(path))
			searches.push(findFiles(path));
	
	await Promise.all(searches).then(results => {
		for(const map of results)
			for(const [path, stats] of map)
				files.set(path, stats);
	});
	return files;
}

async function ls(path){
	const files = await new Promise((resolve, reject) => {
		fs.readdir(path, (error, list) => error
			? reject(error)
			: resolve(list));
	});
	return new Map([...await Promise.all(
		files.map(file => new Promise((resolve, reject) => {
			file = join(path, file);
			fs.lstat(file, (error, stats) => error
				? reject(error)
				: resolve([file, stats]));
		}))
	)]);
}


/**
 * Locate the root directory shared by multiple paths.
 *
 * @param {String[]} paths - A list of filesystem paths
 * @return {String} root
 */
function findBasePath(paths){
	const POSIX = -1 !== paths[0].indexOf("/");
	let matched = [];
	
	// Spare ourselves the trouble if there's only one path.
	if(1 === paths.length){
		matched = (paths[0].replace(/[\\/]+$/, "")).split(/[\\/]/g);
		matched.pop();
	}
	else{
		const rows   = paths.map(d => d.split(/[\\/]/g));
		const width  = Math.max(...rows.map(d => d.length));
		const height = rows.length;
		let x;
		X: for(x = 0; x < width; ++x){
			const str = rows[0][x];
			for(let y = 1; y < height; ++y)
				if(str !== rows[y][x]) break X;
			matched.push(str);
		}
	}
	
	return matched.join(POSIX ? "/" : "\\");
}
