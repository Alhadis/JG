#!/usr/bin/env node
"use strict";

const fs       = require("fs");
const path     = require("path");
const getPath  = require("./path");
const {rmrf}   = require("alhadis.utils");

const shims    = [];
const exists   = path => fs.existsSync(path);
const isFile   = path => exists(path) && fs.lstatSync(path).isFile();
const isDir    = path => exists(path) && fs.lstatSync(path).isDirectory();
const isLink   = path => exists(path) && fs.lstatSync(path).isSymbolicLink();
const debug    = text => +process.env.DEBUG && process.stderr.write(`link: ${text}\n`);

module.exports = {
	fabricateConfig,
	isESLintRelated,
	mkdirp,
	resolveTarget,
	pruneShims,
	shimESLint,
	shimLink,
};


// Allow use from command-line
if(require.main === module || global.$0 === __filename){
	const getOpts = require("get-options");
	const {options, argv} = getOpts(process.argv.slice(2), {
		"-c, --config": "[type|path]",
		"-e, --eslint": "",
	}, {noMixedOrder: true, noUndefined: true, terminator: "--"});
	
	if(options.config){
		const source = path.isAbsolute(options.config)
			? options.config
			: getPath(options.config);
		fabricateConfig(source);
	}
	
	else if(options.eslint)
		shimESLint();
}


/**
 * Create symlinks for ESLint-related dependencies, if needed.
 * @internal
 */
function shimESLint(){
	const modules = path.resolve(`${__dirname}/../node_modules`);
	if(isLink("node_modules") && modules === path.resolve(fs.readlinkSync("node_modules")))
		debug(`Already symlinked: ${path.resolve("node_modules")}`);
	else if(!shimLink(modules)){
		fabricateConfig(getPath("./eslint"), "@alhadis/eslint-config", true);
		const deps = Object.keys(require("../package.json").dependencies);
		for(const dep of deps.filter(isESLintRelated))
			shimLink(`${modules}/${dep}`, "node_modules");
	}
}



/**
 * Create a temporary symlink for a missing project file.
 *
 * Stubborn hack to force ESLint v6+ to work when run globally.
 * Does nothing if something already exists at the given path.
 *
 * @param {String} source - Path of packaged file
 * @param {String} [target=process.cwd()] - Path of project folder
 * @return {Boolean} Whether or not a symlink was necessary and one was created.
 * @internal
 */
function shimLink(source, target = process.cwd()){
	source = path.resolve(source.replace(/[\\/]+/g, path.sep));
	target = path.resolve(target.replace(/[\\/]+/g, path.sep));
	target = resolveTarget(source, target);
	if(exists(target)){
		debug(`Already exists: ${target}`);
		return false;
	}
	debug(`Symlinking: ${source} -> ${target}`);
	fs.symlinkSync(source, target);
	return !!shims.push(target);
}


/**
 * Delete all temporary symlinks created during the current process.
 * @internal
 */
function pruneShims(){
	while(shims.length){
		const link = shims.pop();
		if(!isLink(link)){
			debug(`Not a symlink: ${link}`);
			continue;
		}
		debug(`Unlinking ${link}`);
		fs.unlinkSync(link);
	}
}


/**
 * Create a bogus NPM module which aliases/symlinks a package directory.
 *
 * @param {String} source - Path to directory which should serve as the package root
 * @param {String} [name=""] - Name of NPM module, as it resides under `node_modules/`
 * @param {Boolean} [force=false] - Overwrite existing directories instead of ignoring them
 * @return {Boolean} Whether a fabricated config directory was needed and/or created.
 * @internal
 */
async function fabricateConfig(source, name = "", force = false){
	if(!source)
		throw new TypeError("No source directory specified");
	
	source = source.replace(/[\\/]+/g, path.sep);
	name = name || require(path.join(source, "package.json")).name;
	
	// Module path already exists in working directory
	const target = resolveTarget(source, "node_modules/" + name);
	if(exists(target)){
		if(!force){
			debug(`Not overwriting ${target}`);
			return false;
		}
		if(isLink(target) && source === fs.realpathSync(target)){
			debug(`Already fabricated ${name}`);
			return false;
		}
		
		// Nuke that shit
		debug(`Deleting ${target}`);
		await rmrf(target);
	}
	
	mkdirp(path.dirname(target));
	debug(`Symlinking: ${source} -> ${target}`);
	fs.symlinkSync(source, target);
	return true;
}


/**
 * Create intermediate directories as necessary.
 *
 * @throws {Error} Raises an exception if a path segment exists and isn't a directory.
 * @param {String} target - Path of file whose ancestry should be created, if needed.
 * @returns {void}
 * @internal
 */
function mkdirp(target){
	if(exists(target)) return;
	const dirs = target.split(/[\\/]/);
	const {length} = dirs;
	for(let i = 0; i < length; ++i){
		target = dirs.slice(0, i + 2).join(path.sep);
		if(!exists(target)){
			debug(`Creating directory: ${target}`);
			fs.mkdirSync(target);
		}
		else if(!fs.statSync(target).isDirectory())
			throw new Error(`Not a directory: ${target}`);
	}
}


/**
 * Resolve the full path of a symlink's intended destination.
 *
 * @example resolveTarget("src.txt", "/foo") == "/foo/src.txt";
 * @example resolveTarget("src.txt", "/foo/src.txt") == "/foo/src.txt";
 * @param {String} source - Path of source file
 * @param {String} target - Path of destination (containing directory, or actual symlink)
 * @return {String}
 * @internal
 */
function resolveTarget(source, target){
	source = path.basename(source);
	if(isDir(target))  return path.join(target, source);
	if(exists(target)) return target;
	const {dir, base} = path.parse(path.resolve(target));
	if(exists(dir)){
		if(!fs.statSync(dir).isDirectory())
			throw new Error(`Not a directory: ${dir}`);
		return path.join(dir, base);
	}
	else{
		mkdirp(dir);
		return path.join(dir, base);
	}
}


/**
 * Fathom whether a module name is an ESLint plugin, shared config, or ESLint itself.
 *
 * @example isESLintRelated("@user/eslint-config") == true;
 * @example isESLintRelated("eslint-plugin-name") == true;
 * @example isESLintRelated("eslint-something") == false;
 * @param {String} name
 * @return {Boolean}
 * @internal
 */
function isESLintRelated(name){
	return (
		/^eslint-(?:config|plugin)-.+$/.test(name) ||
		/^@[^@/]+\/eslint-(?:config|plugin)(?:-.+)?$/.test(name)
	);
}
